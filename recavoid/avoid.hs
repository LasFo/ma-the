--this can be decomposed into an dependency graph with two connected components.
--the first component includes the 'readTVar t1' plus the if-then-else and the 
--second is the shift between t5 and t4.
transaction = do
  a <- readTVar t1
  if a < 5
     then writeTVar t2 19
     else writeTVar t3 17
  readTVar t5 **> writeTVar t4

--we assume that rollbacks are performed conservatively, which means 
--every read TVar is a critical TVar.
--connectivity is not the correct term rather than reachability.
transaction = do
  a <- readTVar t1                      --OP1
  if a < 5
     then readTVar t3 **> writeTVar t2  --OP2
     else readTVar t2 **> writeTVar t3  --OP3
  readTVar t5 **> writeTVar t4          --OP4


-------Graph----------
-- t1     t3       t5
-- ||     ||       ||
-- ||     \/       ||
-- \/  -> OP2      \/
--OP1              OP4
--     -> OP3
--        /\
--        ||
--        t2
--This graph indicates if t1 is modified the operation OP1 and the operation OP2 or OP3 need 
--to be reexecuted. WRONG no reexecution for OP2 and OP3 is needed. If the condition is
--unchanged nothing has to be done. If the condition changed the other operation needs 
--to be executed(for its first time).
--If on the other hand t3 is modified just OP2 (if it were executed) needs to be reexecuted.
--Thats why reachability and not connectivity is the desired property

--Another example:
transaction = do 
  a <- readTVar t1
  OP1 a
  b <- readTVar t2
  OP2 a b

-------Graph----------
-- t1     t2
-- ||     ||
-- ||     ||
-- \/     \/
-- OP1    OP2
--        /\
--        ||
--        t1
--This shows that if t1 is modified OP1 and OP2 need to be reexecuted.
--If t2 is modified it is enough to reexecute OP2.

--This shows we need a graph and a collection of elements that point to
--specific nodes of the graph. The overlaying collection contains one 
--element for each accessed TVar with. This element points to the nodes
--that depend on this TVars value. Since the order in which the operation
--appear is important, the graph may no be the best data structure.
--An ordered data structure may be more appropriated.

--Theory:
--What are unnecessary recomputation?
--Some would say computations which result is the same.
--I would restrict it to computations which inputs are the same.
--Since Haskell in a deterministic language same input always lead to same results.
--So compumtations with same input are a subset of computations with same results.
--What does this mean with regards to STM?
--Only readTVars can be invalidated, since they depend heavily on the actual state of
--the TVars. writeTVar on the other hand works independetly from the actual TVar 
--vlaues. But these operation may depend on readTVar operations, thus they are 
--transitively depend on the actual TVar values. In the following example R1 
--depends on t1, R2 on t2, R3 on t4, R4 on t4, R5 on t5, R6 on t5, and R7 on t2 or t4.
--There are more cases. The last two lines below show, that the 'readTVar t4' depends
--on the value of t5, but not on the value of t4.
--In more complex examples it can lead to the fact, that a single
--readTVar depends on multiple TVars rather a single one. 
--The scope of a value generated by readTVar is with a pure Applicative implementation
--tangible, but with Monad this value may be extracted and distributed to all following
--operations. Thus potentially all operations need to be reexecuted. Whereas with a 
--readTVar without bind the value effects at most all operation until the
--next '>>' or '*>'. In the following I will denote inseparable action as chunks.
--The user may define separable sequences as inseparable 
--(e.g. writeTVar t1 5 <**> (\_ -> readTVar t2). A chunk mai contain subchunks.
--This is the case for branch mechanisms, namely if-then-else, case, 
--function (whose result are STM actions that are executed). To reexecute a chunk
--that contains subchunks mean not necessarily to recompute all subchunks. In the case
--of an if-then-else expression we need to compute on subchunk. In the example below 
--the chunk1 has the subchunks 2, 3, and 4. Chunks can depend either on TVar or on 
--other chunks. In this case chunk1 depends on TVar t1, chunk2 on TVar t2, chunk3
--on TVar t4, chunk4 on TVar t4, chunk5 und TVar t5, and chunk6 on chunk5 and chunk2. 
--Note that no transitive dependencies are resolved here. Thus chunk6 depends not on 
--TVar t1, even though the value of t2 depends on the if-then-else condition which on
--the other hand depends on the value of t1.

transaction = do 
  a <- readTVar t1                         --R1 chunk1
  if p a 
    then do readTVar t2 **> writeTVar t3   --R2 chunk2
            readTVar t4 **> writeTVar t2   --R3 chunk3
    else readTVar t4 **> writeTVar ts3     --R4 chunk4
  readTVar t5 **> writeTVar t4             --R5 chunk5
  fmap (,) (readTVar t4) <*> readTVar t2   --R6,R7 chunk6
