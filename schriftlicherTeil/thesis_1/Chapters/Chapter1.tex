
\chapter{Introduction} 

\label{Chapter1} 

\section{Software Transactional Memory}
Software Transactional Memory (STM in the following) is a programming language independend synchronization concept. Today STM is implemented 
in all common programming languages\footnote{Even though STM is language independend, I will present the STM library in Haskell since this thesis is
about STM in Haskell}. To understand the benefits of STM, take a look at the following example:
\begin{lstlisting}
type Account = MVar Int

transfer :: Account -> Account -> Int -> IO ()
transfer src dst am = do
  balSrc <- takeMVar src
  balDst <- takeMVar dst
  putMVar src (balSrc - am)
  putMVar dst (balDst + am)
\end{lstlisting}
This is a simple implementation of a bank account and an associated transfer function. This implementation uses an \code{MVar}
for synchronization. An \code{MVar} is a buffer with a capacity of one. This buffer can either be empty or filled. If the MVar is empty,
every \code{takeMVar} operation on this MVar blocks until it is filled. If the MVar is filled, \code{takeMVar} empties the 
\code{MVar} and return the value. \code{putMVar} is the opposite operation. It fills the MVar with a value, if it is empty and 
suspends if the MVar is already filled.

This means \code{transfer} first empties both \code{Accounts}, then modifies the balances and at last writes back the new balances.
At first glance this function seems to work fine, but the following example contains a deadlock:
\par\noindent
\begin{minipage}[t]{.45\textwidth}
Thread 1:
\begin{lstlisting}[frame=lrtb]
main = do
  transfer acc1 acc2 50
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
Thread 2:
\begin{lstlisting}[frame=lrtb]
main = do
  transfer acc2 ac1 50
\end{lstlisting}
\end{minipage}

The problem is the mutual access of the MVars. If both threads take their \code{src} at the same time, they will both wait for \code{dst}
\footnote{In fact is \code{transfer acc1 acc1 50} enough to evoke a deadlock}. To avoid this deadlock we can rewrite the code:
\begin{lstlisting}
transfer src dst am = do
  srcBal <- takeMVar src
  putMVar src (srcBal - am)
  dstBal <- takeMVar dst
  putMVar dst (dstBal + am)
\end{lstlisting}
This indeed solves the problem regarding the deadlock. In return we lose consistency. For a brief moment we see an inconsistent state. Since
the amount was allready subtracted from one account, but not yet added to another account. This inconsistent state is observable by other 
threads. This was not possible in the first implementation. 

We can use STM to avoid these problems. STM provides a single element buffer named \code{TVar}. A TVar always holds an value and is never 
empty. TVars are read and written with the functions \code{readTVar} and \code{writeTVar}, respectively. 
In contrast to \code{putMVar} and \code{takeMVar} the TVar operations are not \code{IO} actions but STM action. 
\code{STM} is an instance of Monad, hence multiple STM actions can be combined
using the comfortable do-notation. The following code represents the example from above implemented with STM rather than MVars:
\begin{lstlisting}
type Account = TVar Int

transfer :: Account -> Account -> Int -> STM ()
transfer src dst am = do
  srcBal <- readTVar src
  dstBal <- readTVar dst
  writeTVar src (srcBal - am)
  writeTVar dst (dstBal + am)
\end{lstlisting}
Note the type of transfer is no longer an \code{IO} action, but an \code{STM} action. Besided this the code locks
similar to the MVar version.

In order to execute a transaction the function \code{atomically :: STM a -> IO a} is used. 
Since \code{readTVar} and \code{writeTVar} do not lock the TVar they access, the following exmaple evokes no deadlock:
\par\noindent
\begin{minipage}[t]{.45\textwidth}
Thread 1:
\begin{lstlisting}[frame=lrtb]
main = do
  atomically $
    transfer acc1 acc2 50
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
Thread 2:
\begin{lstlisting}[frame=lrtb]
main = do 
  atomically $ 
    transfer acc2 ac1 50
\end{lstlisting}
\end{minipage}

Furthermore does STM library ensures the \keyword{ACID} properties. The ACID properties were Introduced in \parencite{DBTrans}.
In the case of Haskell the ACID properties mean the following:
\begin{itemize}
 \item \keyword{Atomicity}: the transaction executes all operations or none.
 \item \keyword{Consistency}: all modifications of a transaction are committed at the same time. No transition state is observable.
 \item \keyword{Isolation}: no concurrency is observable by a transaction. Each transaction can work as if it is the only transaction.
 \item \keyword{Durability}: ensures the perseverance of the changes. In the case of software transactions this is not necessary.
\end{itemize}
These properties explain the name \code{atomically}. 

Before we turn over to the implementation of STM, we take a look at the rest
of the STM interface. \code{newTVar :: a -> STM (TVar a)} creates a newTVar. Since a TVar always holds a value, an initial value has to be
passed to create a TVar. There is no function like \code{newEmptyTVar}. 

Besides functions to create and access TVars there are functions to alter the control flow.
\code{retry :: STM a} is a generic STM action that indicates a failure, thus whenever a transaction engages a retry it restarts. The transaction
is \textbf{not} restarted immediately. The transaction restarts, if at least one of the TVars it has read is modified. If the transaction would
restart immediately (and no TVar has changed), the transaction would run into retry again. 

With \code{orElse :: STM a $\rightarrow$ STM a $\rightarrow$ STM a} you are able to express alternatives. orElse executes the first transaction
and ignores the second transaction, if the first transaction is successful. If the frist transaction fails (retries), the second transaction is 
executed instead of the first one.

Note that it is not possible to execute IO action withing a transaction, which means that not side effects can occur. Furthermore this means
restarting a transaction will never lead to the reexecution of irreversible operations. The reason is that the computations of transactions
are done within the STM Monad. In other words the type system of Haskell forces us to write correct transactions. 

  
\section{Implementation}
I will now give an overview on the current implementation of STM in Haskell. Afterwards I will analyize the problems of this implementation.

Eventhough the current implementation uses a low level C-library if will retain an abstract view on the implementation, since the technical 
details do not matter for the course of this thesis. I will present an abstract view on the implementation to understand how the ACID 
properties can be achieved.

The execution of a transaction is split in two phases. First the computation phase and second the commit phase. 

\subsection{Computation Phase}
This is the frist phase of a transaction execution. In this phase the reads and all non-STM calculations are performed. 
Aforementioned IO action cannot be executed within a transaction, but pure computation may be executed like the following
example demonstrates:
\begin{lstlisting}
transaction = do 
  val <- readTVar t
  if f val 
    then writeTVar t (g val)
    else retry

f v = some calculations...    
g v = some other calculations...
\end{lstlisting}
Thus even if the calculation of \code{g} can be delayed thanks to laziness, the calculation of f has to be performed within the transaction.

