
\chapter{Introduction} 

\label{Chapter1} 

\section{Software Transactional Memory}
\label{STMInterface}
Software Transactional Memory (STM in the following) is a programming language independent synchronization concept. Today STM is implemented 
in all common programming languages\footnote{Even though STM is language independent, I will present the STM library in Haskell since this thesis is
about STM in Haskell}. To understand the benefits of STM, take a look at the following example:
\begin{lstlisting}
type Account = MVar Int

transfer :: Account -> Account -> Int -> IO ()
transfer src dst am = do
  balSrc <- takeMVar src
  balDst <- takeMVar dst
  putMVar src (balSrc - am)
  putMVar dst (balDst + am)
\end{lstlisting}
This is a simple implementation of a bank account and an associated transfer function. This implementation uses an \code{MVar}
for synchronization. An \code{MVar} is a buffer with a capacity of one. This buffer can either be empty or filled. If the MVar is empty,
every \code{takeMVar} operation on this MVar blocks until it is filled. If the MVar is filled, \code{takeMVar} empties the 
\code{MVar} and return the value. \code{putMVar} is the opposite operation. It fills the MVar with a value, if it is empty and 
suspends if the MVar is already filled.

This means \code{transfer} first empties both \code{Accounts}, then modifies the balances and at last writes back the new balances.
At first glance this function seems to work fine, but the following example contains a deadlock:
\par\noindent
\begin{minipage}[t]{.45\textwidth}
Thread 1:
\begin{lstlisting}[frame=lrtb]
main = do
  transfer acc1 acc2 50
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
Thread 2:
\begin{lstlisting}[frame=lrtb]
main = do
  transfer acc2 acc1 50
\end{lstlisting}
\end{minipage}

The problem is the mutual access of the MVars. If both threads take their \code{src} at the same time, they will both wait for \code{dst}
\footnote{In fact is \code{transfer acc1 acc1 50} enough to evoke a deadlock}. To avoid this deadlock we can rewrite the code:
\begin{lstlisting}
transfer src dst am = do
  srcBal <- takeMVar src
  putMVar src (srcBal - am)
  dstBal <- takeMVar dst
  putMVar dst (dstBal + am)
\end{lstlisting}
This indeed solves the problem regarding the deadlock. In return we lose consistency. For a brief moment we see an inconsistent state. Since
the amount was allready subtracted from one account, but not yet added to the other account. This inconsistent state is observable by other 
threads. This was not possible in the first implementation. 

We can use STM to avoid these problems. STM provides a single element buffer named \code{TVar}. A TVar always holds an value and is never 
empty. TVars are read and written with the functions \code{readTVar} and \code{writeTVar}, respectively. 
In contrast to \code{putMVar} and \code{takeMVar}, the TVar operations are not \code{IO} actions but \code{STM} action\footnote{For 
those who are wondering when I use \code{SMT} and when STM. I use \code{STM} when I refer to the Haskell type contstructor and STM when I refer to STM as library}. 
\code{STM} is an instance of Monad, hence multiple STM actions can be combined
using the comfortable do-notation. The following code represents the example from above implemented with TVars rather than MVars:
\begin{lstlisting}
type Account = TVar Int

transfer :: Account -> Account -> Int -> STM ()
transfer src dst am = do
  srcBal <- readTVar src
  dstBal <- readTVar dst
  writeTVar src (srcBal - am)
  writeTVar dst (dstBal + am)
\end{lstlisting}
Note the type of transfer is no longer an \code{IO} action, but an \code{STM} action. Besided this the code looks
similar to the MVar version.

In order to execute a transaction the function \code{atomically :: STM a -> IO a} is used. 
Since \code{readTVar} and \code{writeTVar} do not lock the TVar, the following exmaple evokes no deadlock:
\par\noindent
\begin{minipage}[t]{.45\textwidth}
Thread 1:
\begin{lstlisting}[frame=lrtb]
main = do
  atomically $
    transfer acc1 acc2 50
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
Thread 2:
\begin{lstlisting}[frame=lrtb]
main = do 
  atomically $ 
    transfer acc2 acc1 50
\end{lstlisting}
\end{minipage}

Furthermore ensures STM the \keyword{ACID} properties. The ACID properties were Introduced in \parencite{DBTrans}.
In the case of software transactions the ACID properties mean the following:
\begin{itemize}
 \item \keyword{Atomicity}: the transaction executes all operations or none.
 \item \keyword{Consistency}: all modifications of a transaction are committed at the same time. No transition state is observable.
 \item \keyword{Isolation}: no concurrency is observable by a transaction. Each transaction can work as if it is the only transaction.
 \item \keyword{Durability}: ensures the perseverance of the changes. In the case of software transactions this is not necessary.
\end{itemize}
These properties explain the name \code{atomically}, because the enclosed code appears to be executed instantaneously wihtout any 
interactions with other threads.
Before we turn over to the implementation of STM, we take a deeper look at the interace of the STM.

\code{newTVar :: a -> STM (TVar a)} creates a newTVar. Since a TVar always holds a value, an initial value has to be
passed to create a TVar. There is no function like \code{newEmptyTVar}. 

Besides functions to create and access TVars, there are functions to alter the control flow.
\code{retry :: STM a} is a generic STM action that indicates a failure, thus whenever a transaction engages a \code{retry} it restarts. The transaction
is \textbf{not} restarted immediately. The transaction restarts, if at least one of the TVars it has read is modified. If the transaction would
restart immediately (and no TVar has changed), the transaction would run into the same \code{retry} again. 

With \code{orElse :: STM a $\rightarrow$ STM a $\rightarrow$ STM a} you are able to express alternatives. \code{orElse} executes the first transaction
and ignores the second transaction, if the first transaction is successful. If the frist transaction fails (retries), the second transaction is 
executed instead of the first one.

Note that it is not possible to execute \code{IO} action within a transaction, which means that not side effects can occur. Furthermore this means
restarting a transaction will never lead to the reexecution of irreversible operations. The reason is that the computations of transactions
are done within the \code{STM} Monad. In other words the type system of Haskell forces us to write correct transactions. 

  
\section{Implementation}
I will now give an overview on the current implementation of STM in Haskell. For a detailed description of the implementation and the theory behind it
refer to \parencite{STMBase}. Afterwards I will analyize the problems with this implementation.

Even though the current implementation uses a low level C-library, I will retain an abstract view on the implementation, since the technical 
details are not important for the course of this thesis. I will present an abstract view on the implementation to understand how the ACID 
properties are ensured.

The execution of a transaction (a call of \code{atomically}) is split in two phases. First the computation phase and second the commit phase. 
 
\subsection{Computation Phase}
In this phase the operations that were written by the user are evaluated. To preseve the ACID properties, the \code{writeTVar} 
operations do not write the actual TVars immediately. Instead the a data structure called \keyword{writeSet} is used. The 
writeSet stores pairs of TVar and value. The 
writeSet fulfills two purposes. First, if a transactions finishes and is found to be valid it needs to commit its changes to the 
actual TVars. These changes are logged in the writeSet. Second, the writeSet serves as a local cache. If the user writes an TVar, 
the TVar and the associated value are entered into the writeSet, not into the actual TVar. If the user reads this TVar afterwards, he 
would not be able able to see his own modifcations, since the actual TVar is unchanged. To see his own modifications every 
\code{readTVar} first looks up the value in the writeSet and returns the associated value if present. Only when the TVar is not 
present in the writeSet, the actual TVar is read. The programmer could keep track of the values he has written himself and thus 
would not need to search these values in the writeSet, but this would hinder the composability, which is an important motivation
for STM.

The TVar not only holds a value, but also a version number, which is updated everytime the TVar is modified.
Additionally a \keyword{readSet} is created for every transactions. This readSet holds pairs of TVars and version numbers. These
version numbers are needed in the commit phase, which is explained in the next section.

Take a look at the following example:
\begin{lstlisting}
transaction = do
  a <- readTVar t1
  b <- readTVar t2
  writeTVar t1 b
  writeTVar t2 a
\end{lstlisting}
This code would lead to the following readSet and writeSet:
\begin{lstlisting}
 readSet  = {(t1,0),(t2,0)}
 writeSet = {(t1,b),(t2,a)}
\end{lstlisting}
Note that the version numbers in the readSet are arbitrarily choosen for this example. The exact value is not important, it only needs to be updated 
to a new unique value everytime it is written by a successful transaction. In this case an increment operation 
is enough to create a new unique value (if we ignore the overflow problem). 

\code{newTVar} creates a new TVar and initializes this TVar. Afterwards this TVar can be used like allready existing TVars.
Even if the transaction is rolled back, the new created TVars are not deleted explicitly. This work is done by the garbage
collector, since the TVars are not further referenced, if the transaction that created them is rolled back. 

\code{retry} aborts the computation and returns a results that indicates a failure. This result may be intercepted by 
\code{orElse} or is passed to \code{atomically} directly. 

If \code{atomically} receives an result that indicates an failure, it aborts the transactions and restarts the transaction as soon as
at least one of the TVars in the readSet has changed. These changes can be checked by comparing the version numbers from the readSet 
with the version numbers from the actual TVars.   

\code{orElse} on the other hand reacts differently on the the result that indicates a failure. Remember the type of 
\code{orElse :: STM a -> STM a -> STM a}. Consider the following example:
\begin{lstlisting}
transaction = do 
  trans1
  trans2 `orElse` trans3
\end{lstlisting}
This transaction first executes \code{trans1}. Before \code{trans2} is executed the current wirteSet is copied (name it ws1 for now). Afterwards 
\code{trans2} is executed. If the execution leads to \code{retry}, the writeSet is set to ws1 and \code{trans3} is executed
\footnote{This means the writes evoked by \code{trans2} until then are discarded.}. The readSet remains unchanged, thus the TVars added
by \code{trans2} are included. If the execution of \code{trans2} leads not to retry, the result, the readSet, and the writeSet produced by 
\code{trans2} are the result of \code{transaction}. In that case \code{trans3} is ignored. 

It is crucial that the readSet produced by \code{trans2} is preserved. Otherwise the TVars read by \code{trans2} may be changed and 
\code{transaction} would not notice this. This would contradict the isolation of the ACID properties. 

In conclusion the interface functions of STM are processed as follows in the computation phase:
\begin{itemize}
 \item \code{writeTVar}: Add TVar and value to writeSet
 \item \code{readTVar}: Lookup the value in writeSet, if not present read the actual TVar and add TVar and version number to the readSet.
 \item \code{newTVar}: Create and initialize a new TVar. 
 \item \code{retry}: Return a result that indicates a failure.
 \item \code{orElse}: Backup the writeSet, execute the first transaction, if it fails restore the writeSet and execute the second transaction, else return the results of the first transaction.
\end{itemize}

\subsection{Commit Phase}
After the readSet and writeSet are calculated and no further STM actions need to be processed, the commit phase starts.
At first the transaction locks all TVars in its readSet in order to avoid concurrency problems at this point.
If a transcation tries to aquire a lock that is already locked, it releases all its locks restarts the commit phase to
avoid deadlocks.

Then the transactions validates\footnote{The transaction not only validates in the commit phase, but also every time the executing
thread yields. This is necessary to detect and roll back transactions, that execute an infinite loop, because they saw inconsistent
data.}. Remember that the readSet is a collection of pairs consisting of a TVar and a version number.
It is sufficient to compare the version numbers stored in the readSet with the version numbers in the actual TVars to validate. 
If all version numbers match, it means the transactions has seen a consistent state
of the system, because no TVar has changed after it was read by the transaction. Thus the transaction is valid.
If there is at least one miss match, it means a TVar was changed after the transaction read it. Thus the isolation
is violated and the transction is invalid.

There are two possible results of the computation phase. First, the result of the computation phase indicates a 
failure (i.e. engaged a \code{retry}). If the transaction is invalid, 
it is rolled back. This means the readSet and writeSet are discarded and the transaction is restarted. If the transaction is
valid, the TVars in the readSet are observed. As soon as one of these TVars is modified, the transaction is rolled back.

Second, the computation phase returns a result that indicates a success.
Depending on the result of the validation the transaction is further processed. If the the transaction is valid, aditionally the
TVars in the writeSet are locked (the TVars in the readSet are not unlocked yet). After that the actual commit is processed. 
The values stored in the writeSet are written to the actual TVars. The version numbers of the written TVars are updated as well.
The last step of the transaction is to unlock the TVars and return the result of the transction to the caller of \code{atomically}.

If the transaction is found to be invalid, the transactions is rolled back after the locks of the TVars has been released.


Lets take a look at the following example:
\begin{lstlisting}
transaction1 = do 
  a <- readTVar t1
  writeTVar t1 (a-1)
  
transaction2 = do 
  a <- readTVar t1
  writeTVar t1 (a+1)
\end{lstlisting}
Assume the transactions are executed parallel and the initial version number of \code{t1} is \code{0} and the initial value of \code{t1} is \code{5}.
If \code{transaction1} first executes its computation phase, its readSet contains \code{(t1,0)}. 
If now \code{transaction2} is executed and finishes the computation phase before \code{transaction1} enter the commit phase,
its readSet contains \code{(t1,0)}. Since the TVars are locked before the validation starts, only one
of the two transactions could validate at a time. 

Assume \code{transaction1} validates first and sees that the version number of \code{t1}
is still \code{0}, hence it is valid. Then \code{transcation1} commits, which is to publish its writeSet.
The writeSet contains \code{(t1,4)}.  Consequently \code{4} is written to \code{t1}. Furthermore is the version number of \code{t1} updated
to \code{1}. In the end \code{t1} is unlocked (and \code{()} is return, because it is the result of \code{writeTVar t1 (a-1)}).


Since \code{t1} is unlocked \code{transaction2} can validate. Now the version number of \code{t1} is \code{1}, but the version
number in the readSet of \code{transaction2} is \code{0}. This means the validation fails and the transactions is rolled back. 
After the reexecution of the computation phase the readSet would contain \code{(t1,1)} and the writeSet \code{(t1,5)}. 
The validation succeeds and the writeSet is published. The result is the intended one. After executing an atomic increment
and an atomic decrement, the TVar value is the same as the inital value.

If there were no validation, \code{transaction2} would also commit at this point in the first try. Thus the value of \code{t1} would be set to \code{6}. This would violate 
the ACID properties. Assuming that the decrement and increment operations are atomic operation, the value of a TVar should not change if it is 
incremented and decremented once.


\section{Problems}
I will now explain two problems with this implmentation. These problems can be examined independently. The first problem is about
\textit{when} a transaction is rolled back and the second problem is about \textit{how} a transaction is rolled back.

\subsection{Unnecessary Rollback}
\label{Prob:UnRo}
Remember the STM implementation of \code{transfer} and its example use given in \ref{STMInterface}: 
\par\noindent
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[frame=lrtb]
transaction1 = do
  atomically $
    transfer acc1 acc2 50
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[frame=lrtb]
transcation2 = do 
  atomically $ 
    transfer acc2 acc1 50
\end{lstlisting}
\end{minipage}
The implmentation is correct, but not verry efficient in this case. Take a look at the inlined functions to understand the 
problem:
\par\noindent
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[frame=lrtb]
transaction1 = do
  a1 <- readTVar acc1
  a2 <- readTVar acc2
  writeTVar acc1 (a1 - 50)
  writeTVar acc2 (a2 + 50)
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[frame=lrtb]
transaction2 = do 
  a1 <- readTVar acc2
  a2 <- readTVar acc1
  writeTVar acc2 (a1 - 50)
  writeTVar acc1 (a2 + 50)
\end{lstlisting}
\end{minipage}

Due to the scheduler the thread can run in a sequential order. This case may occur, but is not desirable. It means 
there is no performce improvement by executing this on a multiple cores/processors. Thus the efforts to use multiple
threads are futile in the first place. This is not a problem specific to STM, but to all synchronization mechanisms. 
If the resulting multi thread program is not scheduled in a way that it is executed parallel, these mechanisms are a
performance deterioration rather than a performance improvement. Since we cannot access the scheduler, we ignore 
this case. 

The second case is that these transactions are run parallel. This should be the better case, because the implementation
has a chance to improve the performance. Sadly this is not the case. To understand why, we need to take a close look at 
the execution. Let us assume both threads execute their computation phase parallel. This means both read the initial 
values of \code{acc1} and \code{acc2} and add these information to their readSet. Furthermore add both transactions 
entries for \code{acc1} and \code{acc2} to their writeSet. Then both transactions try to commit, thus try to lock 
the TVars. If \code{transaction1} gets the locks for \code{acc1} and \code{acc2} it validates and commits, since none of 
the TVars has changed after \code{transaction1} read them. After that \code{transaction2} aquires the locks and validates.
Since \code{transaction1} changed the version numbers of \code{acc1} and \code{acc2} by committing, the validation fails
and \code{transaction2} is restarted. 
In conclusion no performance improvement was achieved. Both threads are still executed 
on after another and not parallel as intended.

if we rearrange the operations of \code{transfer}, we are able to see how this can be improved. Note that we can rearrange the 
operations to a certain degree without changing the semantics of the resulting code due to the ACID properties. 
\begin{lstlisting}
transfer src dst am = do 
  srcBal <- readTVar src
  writeTVar src (srcBal - am)
  dstBal <- readTVar dst
  writeTVar dst (dstBal - am)
\end{lstlisting}
Transfer basically consists of two parts. Decreasing the balance of the source accound and increasing the 
balance of the destination account. The actual values of \code{src} and \code{dst} are not important for
these transactions. If we delay the evaluation of readTVar to the commit phase, we avoid the 
aforementioned \textbf{unnecessary} rollback, because no transaction would read a value, that is overwritten
by another transaction afterwards. 

If we refer to our example: 
\par\noindent
\begin{minipage}[t]{.45\textwidth}
Thread 1:
\begin{lstlisting}[frame=lrtb]
transaction1 = do
  a1 <- readTVar acc1
  a2 <- readTVar acc2
  writeTVar acc1 (a1 - 50)
  writeTVar acc2 (a2 + 50)
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
Thread 2:
\begin{lstlisting}[frame=lrtb]
transaction2 = do 
  a1 <- readTVar acc2
  a2 <- readTVar acc1
  writeTVar acc2 (a1 - 50)
  writeTVar acc1 (a2 + 50)
\end{lstlisting}
\end{minipage}

If we change the semantics of \code{readTVar} by delaying the evaluation, the following happens.
Both transactions will execute the computation phase simultaneously. This means for \code{transaction1} adding
\code{(acc1,(a1 - 50))} and \code{(acc2,(a2 + 50))} to their writeSet (this is analog for \code{transaction2}).
At the first glance this seems to be incorrect since the value of \code{a1} and \code{a2} are not yet present.
For Haskell this is quite common. Haskells is a non-strict language, which means passing unevaluated expressions
is normal. 

After the computation phase the commit phase follows. The first step is to lock the read TVars in order to 
perform the validation. Since both transactions used the same TVars, they will commit successively instead of
parallel. 

Assume \code{transaction1} gets the locks first and trys to validate\footnote{You could argue that 
evaluating \code{readTVar} operation is necessary before validating, but this would not change the validity of the 
transaction, since the TVars are locked and can not be modified by other transactions at that point.}. 
Since the readSet is empty the validation is unnecessary; the empty readSet is always valid. 
Before \code{transaction1} is able to commit its writeSet it needs
to evaluate \code{a1} and \code{a2}. By doing this the \code{readTVar} operations are evaluated. Hence the 
TVar and its version number is added to the readSet and the actual value is return. Since the readSet is already 
validated at this point it is superfluous.

After \code{transaction1} finished and released the locks, \code{transaction2} aquires these locks
and validates. The readSet of \code{transaction2} is also empty, thus the validation succeeds. Then \code{transaction2} 
evaluates the \code{readTVar} operations and commits its writeSet before releasing the locks.

Both transactions run parallel as far as possible and did not roll back. In Chapter \ref{Chapter2}
are the limitations of this idea presented and the challenges that arise when implementing it.
Furthermore are solutions to these challenges introduced.


\subsection{Unnecessary Recomputations}
While the first problem dealed with then question \textit{when} transactions should be rolled back,
the second problem investigates the question \textit{how} transactions are rolled back. Take a look
at the following example:
\begin{lstlisting}
transaction = do 
  a <- readTVar t1	
  writeTVar t1 (f a)	
  b <- readTVar t2	
  writeTVar t2 (g b)	
\end{lstlisting}
This transaction contains two independent statements. The first two lines of the transacton form the first 
statement. This is independent of the last two lines. Independent means their side effects or results do not 
influence each other. While the first line influces the second line, it does not influence the last two lines
and vice versa. 

If the transaction is now executed it computes its writeSet and readSet first. Then it locks the TVars and 
validates. The validation fails if either of the TVar has changed after it was read by the transaction.
If the validation fails the transcation is rolled back. Which means the readSet and writeSet are discarded,
regardless which TVar was the reason for the failed validation. 

For example if \code{t1} was modified after the transaction read it, the transaction is rolled back and both 
statements are executed again. This includes the read and write of \code{t2} although the value of 
\code{t2} did not change. Hence the exact same code with same inputs and the same (relevant) environment is 
executed twice. If we were able to invalidate parts of transactions instead of transactions as a whole, 
we can save time when rolling back a transaction.  

Some may argue it is not common to execute independent statements in a single transaction. However, I do not want  
the performance of the STM library to rely on the capabilities of the programmer. 
Furthermore do I not want to make any asssumption on how the library is most likely be used. 
I am not sure if there
are cases in which the execution of independent statements is needed, but I do not want the user to think 
about this issue. The user should focus on the correctness of the code; the performance is the task of the
library. 

TODO: this technique may even be used for dependent statements aswell by reexecuting just tails of a dependence
chain instead of the whole dependent chains

This concludes the overview on the problems of the current STM implementation. We will now turn over to the 
solution for this problems.







% This is the frist phase of a transaction execution. In this phase the reads and all pure calculations are performed. 
% Aforementioned IO action cannot be executed within a transaction, but pure computation may be executed like the following
% example demonstrates:
% \begin{lstlisting}
% transaction = do 
%   val <- readTVar t
%   if f val 
%     then writeTVar t (g val)
%     else retry
% 
% f v = some calculations...    
% g v = some other calculations...
% \end{lstlisting}
% Thus even if the calculation of \code{g} can be delayed thanks to laziness, the calculation of f has to be performed within that transaction.
% The results of \code{f} effects the control flow and thus needs to be evaluated to determine the result of the branch statement. 
% 
% Since 

