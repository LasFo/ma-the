[1 of 1] Compiling Main             ( test.hs, test.o )

==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 23, types: 21, coercions: 0}

-- RHS size: {terms: 13, types: 15, coercions: 0}
main :: IO ()
[LclIdX, Str=DmdType]
main =
  let {
    $dShow_aMb :: Show [Char]
    [LclId, Str=DmdType]
    $dShow_aMb = GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar } in
  >>=
    @ IO
    GHC.Base.$fMonadIO
    @ [Char]
    @ ()
    (return
       @ IO
       GHC.Base.$fMonadIO
       @ [Char]
       (GHC.CString.unpackCString# "Hello World!"#))
    (\ (a_aqu :: [Char]) -> print @ [Char] $dShow_aMb a_aqu)

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () main

-- RHS size: {terms: 5, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType]
Main.$trModule =
  GHC.Types.Module
    (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Main"#)


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = InitialPhase [Gentle],
             no inline,
             rules,
             eta-expand,
             no case-of-case}
Result size of Simplifier = {terms: 34, types: 42, coercions: 8}

-- RHS size: {terms: 4, types: 4, coercions: 0}
main_s1ew :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 40}]
main_s1ew =
  GHC.Base.build
    @ Char
    (\ (@ b_a1ee) ->
       GHC.CString.unpackFoldrCString# @ b_a1ee "Hello World!"#)

-- RHS size: {terms: 2, types: 2, coercions: 0}
main_s1ev :: IO [Char]
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s1ev = GHC.Base.returnIO @ [Char] main_s1ew

-- RHS size: {terms: 6, types: 6, coercions: 2}
main_s1eB
  :: [Char]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
main_s1eB =
  \ (a_aqu :: [Char])
    (eta_B1 [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    ((print @ [Char] GHC.Show.$fShow[]_$s$fShow[]1 a_aqu)
     `cast` (GHC.Types.N:IO[0] <()>_R
             :: (IO () :: *)
                ~R#
                ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)))
      eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 6}
main_s1ex :: [Char] -> IO ()
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main_s1ex =
  main_s1eB
  `cast` (<[Char]>_R -> Sym (GHC.Types.N:IO[0] <()>_R)
          :: (([Char]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (([Char] -> IO ()) :: *))

-- RHS size: {terms: 3, types: 3, coercions: 0}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 60}]
main = GHC.Base.bindIO @ [Char] @ () main_s1ev main_s1ex

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
:Main.main = GHC.TopHandler.runMainIO @ () main

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Specialise ====================
Result size of Specialise = {terms: 34, types: 42, coercions: 8}

-- RHS size: {terms: 4, types: 4, coercions: 0}
main_s1ew :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 40}]
main_s1ew =
  GHC.Base.build
    @ Char
    (\ (@ b_a1ee) ->
       GHC.CString.unpackFoldrCString# @ b_a1ee "Hello World!"#)

-- RHS size: {terms: 2, types: 2, coercions: 0}
main_s1ev :: IO [Char]
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s1ev = GHC.Base.returnIO @ [Char] main_s1ew

-- RHS size: {terms: 6, types: 6, coercions: 2}
main_s1eB
  :: [Char]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
main_s1eB =
  \ (a_aqu :: [Char])
    (eta_B1 [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    ((print @ [Char] GHC.Show.$fShow[]_$s$fShow[]1 a_aqu)
     `cast` (GHC.Types.N:IO[0] <()>_R
             :: (IO () :: *)
                ~R#
                ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)))
      eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 6}
main_s1ex :: [Char] -> IO ()
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main_s1ex =
  main_s1eB
  `cast` (<[Char]>_R -> Sym (GHC.Types.N:IO[0] <()>_R)
          :: (([Char]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (([Char] -> IO ()) :: *))

-- RHS size: {terms: 3, types: 3, coercions: 0}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 60}]
main = GHC.Base.bindIO @ [Char] @ () main_s1ev main_s1ex

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
:Main.main = GHC.TopHandler.runMainIO @ () main

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Levels added: ====================
<main_s1ew,<0,0>>
<main_s1ew,<0,0>> =
  GHC.Base.build
    @ GHC.Types.Char
    (let {
       <lvl_s1eF,F<0,0>>
       <lvl_s1eF,F<0,0>> =
         \ <b_a1ee,<0,2>> ->
           GHC.CString.unpackFoldrCString# @ b_a1ee "Hello World!"# } in
     lvl_s1eF)
<main_s1ev,<0,0>>
<main_s1ev,<0,0>> = GHC.Base.returnIO @ [GHC.Types.Char] main_s1ew
<main_s1eB,<0,0>>
<main_s1eB,<0,0>> =
  \ <a_aqu,<1,0>> <eta_B1,<1,0>> ->
    ((System.IO.print
        @ [GHC.Types.Char] GHC.Show.$fShow[]_$s$fShow[]1 a_aqu)
     `cast` (GHC.Types.N:IO[0] <()>_R
             :: (GHC.Types.IO () :: *)
                ~R#
                ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)))
      eta_B1
<main_s1ex,<0,0>>
<main_s1ex,<0,0>> =
  main_s1eB
  `cast` (<[GHC.Types.Char]>_R -> Sym (GHC.Types.N:IO[0] <()>_R)
          :: (([GHC.Types.Char]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (([GHC.Types.Char] -> GHC.Types.IO ()) :: *))
<Main.main,<0,0>>
<Main.main,<0,0>> =
  GHC.Base.bindIO @ [GHC.Types.Char] @ () main_s1ev main_s1ex
<:Main.main,<0,0>>
<:Main.main,<0,0>> = GHC.TopHandler.runMainIO @ () Main.main
<$trModule_s1ey,<0,0>>
<$trModule_s1ey,<0,0>> = GHC.Types.TrNameS "main"#
<$trModule_s1ez,<0,0>>
<$trModule_s1ez,<0,0>> = GHC.Types.TrNameS "Main"#
<Main.$trModule,<0,0>>
<Main.$trModule,<0,0>> =
  GHC.Types.Module $trModule_s1ey $trModule_s1ez



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = False}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = False})
  = {terms: 36, types: 49, coercions: 8}

-- RHS size: {terms: 3, types: 3, coercions: 0}
lvl_s1eF
  :: forall b_a1ee. (Char -> b_a1ee -> b_a1ee) -> b_a1ee -> b_a1ee
[LclId, Str=DmdType]
lvl_s1eF =
  \ (@ b_a1ee) ->
    GHC.CString.unpackFoldrCString# @ b_a1ee "Hello World!"#

-- RHS size: {terms: 2, types: 1, coercions: 0}
main_s1ew :: [Char]
[LclId, Str=DmdType]
main_s1ew = GHC.Base.build @ Char lvl_s1eF

-- RHS size: {terms: 2, types: 2, coercions: 0}
main_s1ev :: IO [Char]
[LclId, Arity=1, Str=DmdType]
main_s1ev = GHC.Base.returnIO @ [Char] main_s1ew

-- RHS size: {terms: 6, types: 6, coercions: 2}
main_s1eB
  :: [Char]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=2, Str=DmdType]
main_s1eB =
  \ (a_aqu :: [Char])
    (eta_B1 [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    ((print @ [Char] GHC.Show.$fShow[]_$s$fShow[]1 a_aqu)
     `cast` (GHC.Types.N:IO[0] <()>_R
             :: (IO () :: *)
                ~R#
                ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)))
      eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 6}
main_s1ex :: [Char] -> IO ()
[LclId, Arity=2, Str=DmdType]
main_s1ex =
  main_s1eB
  `cast` (<[Char]>_R -> Sym (GHC.Types.N:IO[0] <()>_R)
          :: (([Char]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (([Char] -> IO ()) :: *))

-- RHS size: {terms: 3, types: 3, coercions: 0}
main :: IO ()
[LclIdX, Arity=1, Str=DmdType]
main = GHC.Base.bindIO @ [Char] @ () main_s1ev main_s1ex

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX, Arity=1, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () main

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId, Str=DmdType]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId, Str=DmdType]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 2 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 33, types: 33, coercions: 9}

-- RHS size: {terms: 15, types: 9, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.Base.build
               @ Char
               (\ (@ b_a1ee) ->
                  GHC.CString.unpackFoldrCString# @ b_a1ee "Hello World!"#))
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 1 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Float inwards ====================
Result size of Float inwards = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Called arity analysis ====================
Result size of Called arity analysis
  = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [post-call-arity],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Demand analysis ====================
Result size of Demand analysis
  = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Worker Wrapper binds ====================
Result size of Worker Wrapper binds
  = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [post-worker-wrapper],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 31, types: 29, coercions: 9}

-- RHS size: {terms: 13, types: 5, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 150 0}]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (GHC.Types.:
         @ Char
         GHC.Show.shows8
         (GHC.Show.showLitString
            (GHC.CString.unpackCString# "Hello World!"#)
            (GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char))))
      GHC.Types.True
      s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Levels added: ====================
<main_s1BH,<0,0>>
<main_s1BH,<0,0>> =
  \ <s_a1BB,<0,1>> ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout
      (let {
         <lvl_s3FS,F<0,0>>
         <lvl_s3FS,F<0,0>> =
           GHC.Types.:
             @ GHC.Types.Char
             GHC.Show.shows8
             (let {
                <lvl_s3FR,F<0,0>>
                <lvl_s3FR,F<0,0>> =
                  GHC.Show.showLitString
                    (let {
                       <lvl_s3FP,F<0,0>>
                       <lvl_s3FP,F<0,0>> = GHC.CString.unpackCString# "Hello World!"# } in
                     lvl_s3FP)
                    (let {
                       <lvl_s3FQ,F<0,0>>
                       <lvl_s3FQ,F<0,0>> =
                         GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows8
                           (GHC.Types.[] @ GHC.Types.Char) } in
                     lvl_s3FQ) } in
              lvl_s3FR) } in
       lvl_s3FS)
      GHC.Types.True
      s_a1BB
<Main.main,<0,0>>
<Main.main,<0,0>> =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (GHC.Types.IO () :: *))
<main_s3FD,<0,0>>
<main_s3FD,<0,0>> =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (GHC.Types.IO () :: *)))
<:Main.main,<0,0>>
<:Main.main,<0,0>> =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (GHC.Types.IO () :: *))
<$trModule_s1ey,<0,0>>
<$trModule_s1ey,<0,0>> = GHC.Types.TrNameS "main"#
<$trModule_s1ez,<0,0>>
<$trModule_s1ez,<0,0>> = GHC.Types.TrNameS "Main"#
<Main.$trModule,<0,0>>
<Main.$trModule,<0,0>> =
  GHC.Types.Module $trModule_s1ey $trModule_s1ez



==================== Float out(FOS {Lam = Just 0, Consts = True, OverSatApps = True}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              OverSatApps = True})
  = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s3FP :: [Char]
[LclId, Str=DmdType]
lvl_s3FP = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
lvl_s3FQ :: [Char]
[LclId, Str=DmdType]
lvl_s3FQ = GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
lvl_s3FR :: String
[LclId, Str=DmdType]
lvl_s3FR = GHC.Show.showLitString lvl_s3FP lvl_s3FQ

-- RHS size: {terms: 3, types: 1, coercions: 0}
lvl_s3FS :: [Char]
[LclId, Str=DmdType]
lvl_s3FS = GHC.Types.: @ Char GHC.Show.shows8 lvl_s3FR

-- RHS size: {terms: 6, types: 2, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType <S,U>]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout lvl_s3FS GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType m]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s3FP :: [Char]
[LclId, Str=DmdType]
lvl_s3FP = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
lvl_s3FQ :: [Char]
[LclId, Str=DmdType]
lvl_s3FQ = GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
lvl_s3FR :: String
[LclId, Str=DmdType]
lvl_s3FR = GHC.Show.showLitString lvl_s3FP lvl_s3FQ

-- RHS size: {terms: 3, types: 1, coercions: 0}
lvl_s3FS :: [Char]
[LclId, Str=DmdType]
lvl_s3FS = GHC.Types.: @ Char GHC.Show.shows8 lvl_s3FR

-- RHS size: {terms: 6, types: 2, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType <S,U>]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout lvl_s3FS GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType m]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Float inwards ====================
Result size of Float inwards = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s3FP :: [Char]
[LclId, Str=DmdType]
lvl_s3FP = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
lvl_s3FQ :: [Char]
[LclId, Str=DmdType]
lvl_s3FQ = GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
lvl_s3FR :: String
[LclId, Str=DmdType]
lvl_s3FR = GHC.Show.showLitString lvl_s3FP lvl_s3FQ

-- RHS size: {terms: 3, types: 1, coercions: 0}
lvl_s3FS :: [Char]
[LclId, Str=DmdType]
lvl_s3FS = GHC.Types.: @ Char GHC.Show.shows8 lvl_s3FR

-- RHS size: {terms: 6, types: 2, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType <S,U>]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout lvl_s3FS GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType m]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Liberate case ====================
Result size of Liberate case = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s3FP :: [Char]
[LclId, Str=DmdType]
lvl_s3FP = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
lvl_s3FQ :: [Char]
[LclId, Str=DmdType]
lvl_s3FQ = GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
lvl_s3FR :: String
[LclId, Str=DmdType]
lvl_s3FR = GHC.Show.showLitString lvl_s3FP lvl_s3FQ

-- RHS size: {terms: 3, types: 1, coercions: 0}
lvl_s3FS :: [Char]
[LclId, Str=DmdType]
lvl_s3FS = GHC.Types.: @ Char GHC.Show.shows8 lvl_s3FR

-- RHS size: {terms: 6, types: 2, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType <S,U>]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout lvl_s3FS GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType m]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [post-liberate-case],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s3FP :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 0}]
lvl_s3FP = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
lvl_s3FQ :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
lvl_s3FQ = GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
lvl_s3FR :: String
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
lvl_s3FR = GHC.Show.showLitString lvl_s3FP lvl_s3FQ

-- RHS size: {terms: 3, types: 1, coercions: 0}
lvl_s3FS :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
lvl_s3FS = GHC.Types.: @ Char GHC.Show.shows8 lvl_s3FR

-- RHS size: {terms: 6, types: 2, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 40 0}]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout lvl_s3FS GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== SpecConstr ====================
Result size of SpecConstr = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s3FP :: [Char]
[LclId, Str=DmdType]
lvl_s3FP = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
lvl_s3FQ :: [Char]
[LclId, Str=DmdType]
lvl_s3FQ = GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
lvl_s3FR :: String
[LclId, Str=DmdType]
lvl_s3FR = GHC.Show.showLitString lvl_s3FP lvl_s3FQ

-- RHS size: {terms: 3, types: 1, coercions: 0}
lvl_s3FS :: [Char]
[LclId, Str=DmdType]
lvl_s3FS = GHC.Types.: @ Char GHC.Show.shows8 lvl_s3FR

-- RHS size: {terms: 6, types: 2, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType <S,U>]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout lvl_s3FS GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId, Arity=1, Str=DmdType]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId, Str=DmdType m1]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX, Str=DmdType m]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [final],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
lvl_s3FP :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 0}]
lvl_s3FP = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
lvl_s3FQ :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
lvl_s3FQ = GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
lvl_s3FR :: String
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
lvl_s3FR = GHC.Show.showLitString lvl_s3FP lvl_s3FQ

-- RHS size: {terms: 3, types: 1, coercions: 0}
lvl_s3FS :: [Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
lvl_s3FS = GHC.Types.: @ Char GHC.Show.shows8 lvl_s3FR

-- RHS size: {terms: 6, types: 2, coercions: 0}
main_s1BH
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 40 0}]
main_s1BH =
  \ (s_a1BB [Dmd=<S,U>, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout lvl_s3FS GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s1BH
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  main_s1BH
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
main_s3FD
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
main_s3FD =
  GHC.TopHandler.runMainIO1
    @ ()
    (main_s1BH
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= main_s3FD
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  main_s3FD
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ey :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ey = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
$trModule_s1ez :: GHC.Types.TrName
[LclId,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
$trModule_s1ez = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module $trModule_s1ey $trModule_s1ez


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad_a1aO @ a_a1aQ a_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== Tidy Core ====================
Result size of Tidy Core = {terms: 39, types: 36, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
Main.main5 :: [Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 60 0}]
Main.main5 = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
Main.main4 :: [Char]
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.main4 =
  GHC.Types.: @ Char GHC.Show.shows8 (GHC.Types.[] @ Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.main3 :: String
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 30 0}]
Main.main3 = GHC.Show.showLitString Main.main5 Main.main4

-- RHS size: {terms: 3, types: 1, coercions: 0}
Main.main2 :: [Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.main2 = GHC.Types.: @ Char GHC.Show.shows8 Main.main3

-- RHS size: {terms: 6, types: 2, coercions: 0}
Main.main1
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 40 0}]
Main.main1 =
  \ (s_a1BB [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout Main.main2 GHC.Types.True s_a1BB

-- RHS size: {terms: 1, types: 0, coercions: 3}
main :: IO ()
[GblId,
 Arity=1,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Main.main1
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
main =
  Main.main1
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 1, coercions: 3}
Main.main6
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
Main.main6 =
  GHC.TopHandler.runMainIO1
    @ ()
    (Main.main1
     `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
             :: ((GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                ~R#
                (IO () :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 3}
:Main.main :: IO ()
[GblId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= Main.main6
               `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                       :: ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                          ~R#
                          (IO () :: *))}]
:Main.main =
  Main.main6
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
Main.$trModule2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
Main.$trModule2 = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
Main.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
Main.$trModule1 = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module Main.$trModule2 Main.$trModule1


------ Local rules for imported ids --------
"TESTRULE" [ALWAYS]
    forall (@ a_a1aQ)
           ($dMonad_a1aK :: Monad IO)
           ($dMonad1_a1aO :: Monad IO)
           ($dShow_a1aR :: Show a_a1aQ)
           (a1_auu :: a_a1aQ).
      >>= @ IO
          $dMonad_a1aK
          @ a_a1aQ
          @ ()
          (return @ IO $dMonad1_a1aO @ a_a1aQ a1_auu)
          (print @ a_a1aQ $dShow_a1aR)
      = print
          @ [Char]
          (GHC.Show.$fShow[] @ Char GHC.Show.$fShowChar)
          (GHC.CString.unpackCString# "Hello World"#)



==================== CorePrep ====================
Result size of CorePrep = {terms: 45, types: 42, coercions: 9}

-- RHS size: {terms: 2, types: 0, coercions: 0}
Main.main5 :: [GHC.Types.Char]
[GblId, Str=DmdType]
Main.main5 = GHC.CString.unpackCString# "Hello World!"#

-- RHS size: {terms: 3, types: 2, coercions: 0}
Main.main4 :: [GHC.Types.Char]
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
Main.main4 =
  GHC.Types.:
    @ GHC.Types.Char GHC.Show.shows8 (GHC.Types.[] @ GHC.Types.Char)

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.main3 :: GHC.Base.String
[GblId, Str=DmdType]
Main.main3 = GHC.Show.showLitString Main.main5 Main.main4

-- RHS size: {terms: 3, types: 1, coercions: 0}
Main.main2 :: [GHC.Types.Char]
[GblId, Str=DmdType, Unf=OtherCon []]
Main.main2 =
  GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 Main.main3

-- RHS size: {terms: 6, types: 2, coercions: 0}
Main.main1
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=1, Str=DmdType <S,U>, Unf=OtherCon []]
Main.main1 =
  \ (s_s3FU [Occ=Once, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.IO.Handle.Text.hPutStr2
      GHC.IO.Handle.FD.stdout Main.main2 GHC.Types.True s_s3FU

-- RHS size: {terms: 3, types: 2, coercions: 3}
Main.main :: GHC.Types.IO ()
[GblId, Arity=1, Str=DmdType <S,U>, Unf=OtherCon []]
Main.main =
  (\ (eta_B1 [Occ=Once, OS=OneShot]
        :: GHC.Prim.State# GHC.Prim.RealWorld) ->
     Main.main1 eta_B1)
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (GHC.Types.IO () :: *))

-- RHS size: {terms: 4, types: 3, coercions: 3}
Main.main6
  :: GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []]
Main.main6 =
  \ (eta_B1 [Occ=Once, OS=OneShot]
       :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    GHC.TopHandler.runMainIO1
      @ ()
      (Main.main1
       `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
               :: ((GHC.Prim.State# GHC.Prim.RealWorld
                    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
                  ~R#
                  (GHC.Types.IO () :: *)))
      eta_B1

-- RHS size: {terms: 3, types: 2, coercions: 3}
:Main.main :: GHC.Types.IO ()
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []]
:Main.main =
  (\ (eta_B1 [Occ=Once, OS=OneShot]
        :: GHC.Prim.State# GHC.Prim.RealWorld) ->
     Main.main6 eta_B1)
  `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
          :: ((GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)) :: *)
             ~R#
             (GHC.Types.IO () :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
Main.$trModule2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType m1, Unf=OtherCon []]
Main.$trModule2 = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
Main.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType m1, Unf=OtherCon []]
Main.$trModule1 = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=DmdType m, Unf=OtherCon []]
Main.$trModule = GHC.Types.Module Main.$trModule2 Main.$trModule1



Linking test ...
